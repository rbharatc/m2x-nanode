<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AT&amp;T&#39;s M2X Nanode Client Library: Nanode M2X API Client</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AT&amp;T&#39;s M2X Nanode Client Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Nanode M2X API Client </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The AT&amp;T M2X API provides all the needed operations to connect your device to AT&amp;T's <a href="http://m2x.att.com">M2X</a> service. This client provides an easy to use interface for <a href="http://www.nanode.eu">Nanode</a> microcontroller based devices. This client library supports writing data from a Nanode devices to M2X but does not support reading data back out from the M2X service.</p>
<h2>Getting Started</h2>
<ol type="1">
<li>Signup for an <a href="https://m2x.att.com/signup">M2X Account</a>.</li>
<li>Obtain your <em>Master Key</em> from the Master Keys tab of your <a href="https://m2x.att.com/account">Account Settings</a> screen.</li>
<li>Create your first <a href="https://m2x.att.com/devices">Device</a> and copy its <em>Device ID</em>.</li>
<li>Review the <a href="https://m2x.att.com/developer/documentation/overview">M2X API Documentation</a>.</li>
</ol>
<p>Please consult the <a href="https://m2x.att.com/developer/documentation/glossary">M2X glossary</a> if you have questions about any M2X specific terms.</p>
<h2>How to Use the Library</h2>
<ol type="1">
<li><p class="startli">Clone <a href="https://github.com/xxuejie/ethercard">ethercard</a> library:</p>
<p class="startli">$ git clone <a href="https://github.com/xxuejie/ethercard">https://github.com/xxuejie/ethercard</a></p>
</li>
<li>Open the Arduino IDE, click <code>Sketch</code>-&gt;<code>Import Library...</code>-&gt;<code>Add Library...</code>, navigate and select the ethercard repo folder, click <code>OK</code> to import the libray into Arduino.</li>
<li><p class="startli">Clone <a href="https://github.com/attm2x/m2x-nanode">m2x-nanode</a> library:</p>
<p class="startli">$ git clone <a href="https://github.com/attm2x/m2x-nanode">https://github.com/attm2x/m2x-nanode</a></p>
</li>
<li>Use the process outlined in Step #2 above to import <code><a class="el" href="class_m2_x_nanode_client.html" title="Wrapper for AT&amp;T M2X API ">M2XNanodeClient</a></code> in this repo. Note that while in Step #2, we are selecting the repo folder <code>ethercard</code>, in this step we are selecting a sub-directory of the repo.</li>
<li>Open one of the Nanode examples in <code>File</code>-&gt;<code>Examples</code>-&gt;<code><a class="el" href="class_m2_x_nanode_client.html" title="Wrapper for AT&amp;T M2X API ">M2XNanodeClient</a></code>.</li>
<li>Change <code>Device ID</code>, <code>Stream Name</code> and <code>M2X Key</code> fields to contain correct values (from your M2X account).</li>
<li>Set the board type to Arduino UNO via <code>Tools</code> -&gt; <code>Board Type</code> -&gt; <code>Arduino UNO</code>.</li>
<li>Now you can run the examples!</li>
</ol>
<p><b>NOTE</b>: For simplicity, all of provided examples use fixed values as inputs. If you want to use values obtained from real sensors as inputs, please refer to <a href="http://shop.wickeddevice.com/2013/10/16/nanode-gatewayremote-sensing-tutorial-1/">this tutorial</a> for the value gathering functionality.</p>
<h2>Client API</h2>
<p>Due to the memory limitations of Nanode boards, most of the APIs provided work in a callback-based approach:</p>
<ol type="1">
<li>You define one or more function(s) to provide the data needed.</li>
<li>You pass the function(s) as parameter(s) to API calls.</li>
<li>The library will invoke provided function(s) as callbacks to fill in necessary data.</li>
</ol>
<p>For more details on how this works, please refer to the examples.</p>
<h3>UpdateStreamValue API</h3>
<p>The UpdateStreamValue API is the simplest approach to pushing data into M2X. The API interface is as follows:</p>
<div class="fragment"><div class="line">typedef void (*put_data_fill_callback)(Print* print);</div><div class="line">int updateStreamValue(const char* device_id, const char* stream_name,</div><div class="line">                      put_data_fill_callback cb);</div></div><!-- fragment --><p>A sample callback function will look like the following:</p>
<div class="fragment"><div class="line">static int val = 11;</div><div class="line">void fill_data_cb(Print* print) {</div><div class="line">  print-&gt;print(val);</div><div class="line">}</div></div><!-- fragment --><p>If you want to pass strings as values, you need to include double-quotes:</p>
<div class="fragment"><div class="line">void fill_data_cb(Print* print) {</div><div class="line">  print-&gt;print(&quot;\&quot;11\&quot;&quot;);</div><div class="line">}</div></div><!-- fragment --><h3>PostStreamValues API</h3>
<p>PostStreamValues API has the following differences from UpdateStreamValue API:</p>
<ol type="1">
<li>You can push multiple values in one request;</li>
<li>For each value, you also need to provide an ISO8601-formatted timestamp.</li>
</ol>
<p>The calling interface for this API is as follows:</p>
<div class="fragment"><div class="line">typedef void (*post_data_fill_callback)(Print* print, int index);</div><div class="line">int postStreamValues(const char* device_id, const char* stream_name, int value_number,</div><div class="line">                     post_data_fill_callback timestamp_cb,</div><div class="line">                     post_data_fill_callback data_cb);</div></div><!-- fragment --><p>Notice here that we use two callback functions: one for timestamp, and one for data. For each callback function, the client library will invoke it <code>value_number</code> times, each time for a different value to be pushed.</p>
<p>Notice for timestamp and string-typed values, double quotes are needed:</p>
<div class="fragment"><div class="line">static int seconds = 10;</div><div class="line">void fill_timestamp_cb(Print* print, int index) {</div><div class="line">  print-&gt;print(&quot;\&quot;2014-07-09T19:&quot;);</div><div class="line">  print-&gt;print(15 + index);</div><div class="line">  print-&gt;print(&quot;:&quot;);</div><div class="line">  print-&gt;print(seconds);</div><div class="line">  print-&gt;print(&quot;.624Z\&quot;&quot;);</div><div class="line">}</div></div><!-- fragment --><h3>PostDeviceUpdates API</h3>
<p>PostDeviceUpdates API has one more advantage over the PostStreamValues API: it allows pushing multiple values to multiple streams in one request. As a result, the calling interface for this API is more complex:</p>
<div class="fragment"><div class="line">typedef int (*post_multiple_stream_fill_callback)(Print* print, int stream_index);</div><div class="line">typedef void (*post_multiple_data_fill_callback)(Print* print, int value_index, int stream_index);</div><div class="line">int postDeviceUpdates(const char* device_id, int stream_number,</div><div class="line">                      post_multiple_stream_fill_callback stream_cb,</div><div class="line">                      post_multiple_data_fill_callback timestamp_cb,</div><div class="line">                      post_multiple_data_fill_callback data_cb);</div></div><!-- fragment --><p>First, <code>stream_number</code> denotes how many streams we are pushing to. For each stream, <code>stream_cb</code> will be called with the corresponding index, this callback function has 2 effects:</p>
<ol type="1">
<li>It prints the stream name into <code>print</code>(double quotes needed);</li>
<li>It returns the number of values we want to push for this stream.</li>
</ol>
<p>Suppose during the <code>i</code>th time we call <code>stream_cb</code>, <code>j</code> is returned as a result. Then we will call <code>timestamp_cb</code> callback function <code>j</code> times, with <code>i</code> as <code>stream_index</code>, and <code>0</code> through <code>j-1</code> as <code>value_index</code>, each time, we are getting the timestamp for the value to push.</p>
<p>We are also calling <code>data_cb</code> the same number of times with the same input parameter to get the value to push.</p>
<p>Notice that for all callback functions, if string values are printed, double quotes are needed.</p>
<h3>Update Location API</h3>
<p>The update Location API can be used to update the location of a device. The calling interface is as follows:</p>
<div class="fragment"><div class="line">// Values of data type:</div><div class="line">// 1 - Latitude</div><div class="line">// 2 - Longitude</div><div class="line">// 3 - Name</div><div class="line">// 4 - Elevation</div><div class="line">typedef void (*update_location_data_fill_callback)(Print* print, int data_type);</div><div class="line">int updateLocation(const char* device_id, int has_name, int has_elevation,</div><div class="line">                   update_location_data_fill_callback cb);</div></div><!-- fragment --><p>In this API request, <code>name</code> and <code>elevation</code> are optional values. <code>has_name</code> and <code>has_elevation</code> thus determine if <code>name</code> and <code>elevation</code> are present respectively: 1 for present, 0 for absent.</p>
<p>Depending on the values <code>has_name</code> and <code>has_elevation</code>, the callback function will be called 2 - 4 times. Each time, a different <code>data_type</code> value is used, so we can know which value is requested right now.</p>
<p>Like all the requests outlined above, if string-typed values are printed, double quotes are needed as well.</p>
<h3>Delete Values API</h3>
<p>Delete Values API can be used to delete values within a specific time range. The calling API is as follows:</p>
<div class="fragment"><div class="line">// Values for timestamp type:</div><div class="line">// 1 - Start Time</div><div class="line">// 2 - End Time</div><div class="line">typedef void (*delete_values_timestamp_fill_callback)(Print* print, int type);</div><div class="line">int deleteValues(const char* device_id, const char* stream_name,</div><div class="line">                 delete_values_timestamp_fill_callback timestamp_cb);</div></div><!-- fragment --><p>Following is an example of the callback function:</p>
<div class="fragment"><div class="line">void fill_timestamp_cb(Print* print, int type) {</div><div class="line">  if (type == 1) {</div><div class="line">    print-&gt;print(&quot;\&quot;2014-07-01T00:00:00.000Z\&quot;&quot;);</div><div class="line">  } else {</div><div class="line">    print-&gt;print(&quot;\&quot;2014-07-30T00:00:00.000Z\&quot;&quot;);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2>Known Issues</h2>
<ul>
<li>In our tests with Nanode based devices, we found that there is a small chance that an API request may timeout. This occurs inside the ethercard library: our internal callback functions are not called at all. We suspect that this may be related to the way TCP/IP is implemented in the library, or our way of using the library (we might accidently set the wrong parameter for some option).</li>
<li>Unlike the Arduino client library, fetching values is not supported in the Nanode library. This is because <a href="https://github.com/xxuejie/ethercard">ethercard</a> does not support packet streaming: when a packet arrives, ethercard will read all the data into memory before handling over control to our code. Considering the fact that a Nanode only has 2kb memory, and that a simple M2X List Value API response contains 4k-5k data, we can never process this request on Nanode successfully.</li>
</ul>
<h2>License</h2>
<p>The Nanode M2X API Client is available under the MIT license. See the [LICENSE](LICENSE) file for more information. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
